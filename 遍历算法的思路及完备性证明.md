**ergodic.m- 遍历算法**
>  算法复杂度即所有符合条件的数组个数，复杂度为：0.5*(1/ln(2)^(n+1))\*n!)，当n=7时，运行时间为1分钟，再增加可能运行时间较长。这个复杂度是拟合出来的，期待理论证明。

> - 这是一个减而治之的算法，要生成n的所有数组，首先生成n-1的，然后把其中所有大于n-1的元素+2,然后用[n,n+1]或[n+1,n]插入，这个插入需要满足一定条件，用[2,4,1,3]来说明:
>   - 先+2得到[2,6,1,5]，然后用[3,4]或[4,3]插入其中(因为数组的对称性质，只需要对数组的前半段做插入操作，后半段对称地自动补齐)
>   - 首先，数组的中间位置，在这里为[6,1]之间，只能插入[4,3]不能插入[3,4]，在程序中先插入这一组数，插入后的结果是[2,6,4,3,1,5]，是一个n=3时满足条件的数组
>   - 然后定义一个指针p,它指向前半段数组中的元素，指针初始化为n-1(=2，即指向6这个元素)。判断此时p位置的元素是否大于p+1:
>     - 如果大于，那么在此处必然可以插入一组[n+1,n]和[n,n+1]
>     - 如果不大于(由于需要满足x>p,那么x<=p+1 等价于x=p+1)，那么从此位置开始，它之前的位置都不能插入新的元素，即退出循环。
>   - 然后p=p-1，若p==0也应退出循环。

> - 对[2,6,1,5]来说
>   - 首先中间可以插入[4,3]变为[2,6,4,3,1,5]
>   - 然后指针p=2,指向元素6，此时6>p+1=3，所以在6和1的外侧插入[4,3]和[3,4]，得到
[2,4,6,1,3,5]和[2,3,6,1,4,5]
>   - 然后p=p-1=1，指向元素2，此时2==p+1，所以它的外侧不能插入[4,3]和[3,4]，退出循环
> - 如果是对于[6,5,2,1]
>   - 那么当p=1时，仍然可以插入，得到[4,6,5,2,1,3]和[3,6,5,2,1,4]
>   - 然后p=p-1=0, 退出循环

> - 上面这个插入操作是完备的，即你只能在这些位置插入[n,n+1]和[n+1,n]。
> - 要证明整个算法的完备性，就要证明对于一个满足条件的数组，取出n和n+1后，再把其中所有大于n-1的元素减2，得到的数组必然满足n-1时的所有条件。
> - 显然取出n和n+1并且做减法是满足唯一性和对称性的，所以只需要证明条件3成立。

> 设变换前数组中的一个元素为x,它的坐标为i, (i<=n-1，即只需要证明前一半的元素)
设变换后该元素为x',i'，需要由x>i证明x'>i'。分几种情况:
  > 1. 若x>i+1:
   根据算法规则此时删除n和n+1可以在x的右侧或两侧进行，在两侧进行的删除会使得i'=i-1，右侧是i'=i
   所以i'<=i
  >    1. 若x'=x 
        则x' = x > i  >=i' 即x'>i'
  >    2. 若x'=x-2
        则x>n+1
        则x'=x-2>n-1>=i>=i' 即x'>i' 
  > 2. 若x==i+1:
   根据算法规则此时删除n和n+1只能在x的右侧进行，即i'=i
  >    1. x'=x
        则x'=x>i=i'
  >    2. x'=x-2
        则x>n+1
        x'=x-2>n-1>=i=i' 即x'>i'

> 以上证明了经过删除和减2操作后，得到的数组仍然满足n-1的条件，所以可以通过+2和插入操作来遍历n的所有情况。
